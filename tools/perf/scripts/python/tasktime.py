# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-trace-python Documentation for the list of available functions.

import os
import sys
import re

sys.path.append(os.environ['PERF_EXEC_PATH'] + \
	'/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

from perf_trace_context import *
from Core import *

time_table = {}
wait_table = {}
evcount = {}
sample_count = {}
wait_pattern = ".*[^Bb][Ll]ock.*|.*[Mm]utex.*|pthread_.*|sys_.*|page_fault"
ignore_pattern = "sys_wait4|sys_vfork"
wait_regex = None
ignore_regex = None

total_time = 0

def trace_begin():
	global wait_pattern, wait_regex, ignore_pattern, ignore_regex
	wait_regex = re.compile(wait_pattern)
	ignore_regex = re.compile(ignore_pattern)

	import signal
	signal.signal(signal.SIGINT, lambda s, f: sys.exit(1))
	signal.signal(signal.SIGPIPE, lambda s, f: sys.exit(1))

def trace_end():
	output = [(k,time_table[k]) for k in time_table]
	output.sort(key=lambda e: e[1], reverse=True)

	print " Overhead    Pid:Command           Shared Object         Symbol"
	print " --------  ----------------------  --------------------  ----------------"
	for entry in output:
		key = entry[0].split(',')
		print "  %6.2f%%  %5s:%-16s  %-20s  %s" % \
		    ((100.0 * entry[1] / total_time), key[0], key[1], key[2], key[3])

	print
	print "[event stats]"
	print "Total time: %.6f sec" % (total_time / 1000000000)
	print "Number of events:"
	for k in evcount:
		print "   ", k, evcount[k]

def sched__sched_switch(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, prev_comm, prev_pid, prev_prio, prev_state,
	next_comm, next_pid, next_prio):

	global total_time
	if 'sched_switch' not in evcount:
		evcount['sched_switch'] = 0
	evcount['sched_switch'] += 1

	ts = common_secs * 1000000000 + common_nsecs

	if prev_state == 1: # S
		name = "sleep"
	elif prev_state == 2: # D
		name = "iowait"
	elif prev_state == 16 or prev_state == 32: # t or X
		name = "exit"
	else:
		name = "context-switch"
	dso = '[unknown]'

	if common_callchain:
		for entry in reversed(common_callchain):
			if 'sym' not in entry:
				continue
			symname = entry['sym']['name']
			if symname and wait_regex.match(symname):
				if ignore_regex.match(symname):
					return  # discard wait time
				name = "wait: " + symname
				dso = os.path.basename(entry['dso'])
				break

	key = ','.join([str(prev_pid), common_comm, dso, name])
	if key not in sample_count:
		sample_count[key] = 0
	sample_count[key] += 1
	if prev_pid not in wait_table:
		wait_table[prev_pid] = []
	wait_table[prev_pid].append({'start': ts, 'end': 0, 'key': key,
				     'prev': prev_comm, 'next': next_comm })

def process_event(param_dict):
	global total_time
	event = param_dict['ev_name']
	if event not in evcount:
		evcount[event] = 0
	evcount[event] += 1

	tid = param_dict['sample']['tid']
	comm = param_dict['comm']
	if 'dso' in param_dict:
		dso = os.path.basename(param_dict['dso'])
	else:
		dso = '[unknown]'
	if 'symbol' in param_dict:
		sym = param_dict['symbol']
	else:
		sym = "0x%x" % param_dict['sample']['ip']

	key = ','.join([str(tid), comm, dso, sym])
	if key not in time_table:
		time_table[key] = 0
	time_table[key] += param_dict['sample']['period']
	total_time += param_dict['sample']['period']

	if key not in sample_count:
		sample_count[key] = 0
	sample_count[key] += 1

	if tid in wait_table and len(wait_table[tid]) > 0 and wait_table[tid][-1]['end'] == 0:
		ts_end = param_dict['sample']['time']
		wait_table[tid][-1]['end'] = ts_end - param_dict['sample']['period']
		waittime = wait_table[tid][-1]['end'] - wait_table[tid][-1]['start']
		if waittime <= 0:
			waittime = param_dict['sample']['period'] / 2
		key = wait_table[tid][-1]['key']
		if key not in time_table:
			time_table[key] = 0
		time_table[key] += waittime
		total_time += waittime

def trace_unhandled(event_name, context, event_fields_dict):
		print ' '.join(['%s=%s'%(k,str(v))for k,v in sorted(event_fields_dict.items())])
